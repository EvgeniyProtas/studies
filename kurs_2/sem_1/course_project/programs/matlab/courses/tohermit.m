function [s,m]=tohermit(b,y0,y1,z1)
% [s,m]=toHermit(b[,y0,y1,z1])
% преобразование сплайнового базиса в эрмитову форму
% b - отсчеты симметрического сплайнового базиса
%      сплайн состоит из четырех узлов
% y0 - значение сплайна в центральном узле
% y1 - значение сплайна в боковых узлах
% z1 - значение производной сплайна в левом узле
% s  - новый базис
% m  - матрица переобразования
%   

n = length(b);
N=round(n/4);
if N*4-n>1
   error('size incorrect !')
end
if nargin == 1
        y0 = b(2*N);
        y1 = b(N);
        z1 = (b(N+1)-b(N-1))/(2/N);
end
if nargin == 3
        z1 = (b(N+1)-b(N-1))/(2/N);
end
                            
d=2*(z1*(y0*y0-4*y1*y1));
if abs(d)<0.00000001
   error('bad base !')
end

m=zeros(4,4);
s=zeros(1,n);

m(3,1)=2*y0*z1+2*y1*y1-y0*y0;
m(3,2)=-4*y1*z1+y1*y0;
m(3,3)=2*y0*z1-2*y1*y1;
m(3,4)=-4*y1*z1+y1*y0;

m(2,1)=-4*y1*z1+y1*y0;
m(2,2)=2*y0*z1-2*y1*y1;
m(2,3)=-4*y1*z1+y1*y0;
m(2,4)=2*y1*y1+2*y0*z1-y0*y0;

m(4,1)=-y1*y0;
m(4,2)=2*y1*y1;
m(4,3)=-y1*y0;
m(4,4)=y0*y0-2*y1*y1;

m(1,1)=y0*y0-2*y1*y1;
m(1,2)=-y1*y0;
m(1,3)=2*y1*y1;
m(1,4)=-y1*y0;

m=m/d;

for i=1:N,
  s(i)    =m(1,1)*b(i)+m(1,2)*b(i+N)+m(1,3)*b(i+2*N)+m(1,4)*b(i+3*N);
  s(i+N)  =m(2,1)*b(i)+m(2,2)*b(i+N)+m(2,3)*b(i+2*N)+m(2,4)*b(i+3*N);
  s(i+2*N)=m(3,1)*b(i)+m(3,2)*b(i+N)+m(3,3)*b(i+2*N)+m(3,4)*b(i+3*N);
  s(i+3*N)=m(4,1)*b(i)+m(4,2)*b(i+N)+m(4,3)*b(i+2*N)+m(4,4)*b(i+3*N);
end

